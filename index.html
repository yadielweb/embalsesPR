<!DOCTYPE html>
<html>
<head>
<title>Quick Start - Leaflet</title>

<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link rel="shortcut icon" type="image/x-icon" href="docs/images/favicon.ico" />

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" 
      integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A=="          
      crossorigin=""/>
<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js" 
        integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA=="   
        crossorigin=""></script>

<script src='https://cdn.plot.ly/plotly-latest.min.js'></script>
</head>
<body>
    <h1>embalsesPR.V2 by Yadiel</h1>
    <div id="mapid" style="width: 800px; height:600px;"></div>
    <div class="col-sm-4">
        <form class="well">
          <p align="justify"><font color="Maroon">embalsesPR</font> es una aplicación para <font color="blue">buscar</font> y 
            <font color="blue">visualizar</font> el estado actual de 
            los embalses en Puerto Rico utilizando datos del Servicio Geológico de los Estados Unidos 
            (USGS por sus siglas en inglés). Dependiendo del tráfico en el servidor (y los 
            instrumentos del USGS) el tiempo de búsqueda puede variar. Según USGS los datos 
            tienen estado provisional y podrian variar luego de una revisión. De ser necesario 
            recarge la página.</p>
          <button id="buscaDatos" type="button" class="btn btn-default action-button shiny-bound-input">
            <i class="fa fa-search"></i>
            Buscar datos..
          </button>
          <br>
          <div data-display-if="input.buscaDatos == true" data-ns-prefix="" style="display: none;"><p align="justify"> </p><ul style="padding-left:20px;text-align:justify;"> <li>La <font color="blue"> <b>altura </b> </font> 
             de los rectángulos de color es proporcional al <font color="blue"><b>nivel del embalse</b></font> 
             y la flecha indica la   <font color="blue"><b>tendencia del nivel </b></font> en 
             las últimas horas</li> <li><font color="blue"><b>Oprima</b></font>  en los rectángulos para obtener mas información y una gráfica 
             del nivel en las pasadas horas.</li> 
             <li>El código de colores, y los niveles de alerta están 
              basadas en información oficial provista en  <font color="blue">http://acueductospr.com.</font> 
              </li></ul> <p></p></div>
          <div class="form-group shiny-input-container">
            <div class="checkbox">
              <label>
                <input id="rectangulo" type="checkbox" checked="checked" class="shiny-bound-input">
                <span>Mostrar gráfica de estado actual</span>
              </label>
            </div>
          </div>
          <div class="form-group shiny-input-container">
            <div class="checkbox">
              <label>
                <input id="nombre" type="checkbox" checked="checked" class="shiny-bound-input">
                <span>Mostrar nombres de los embalses</span>
              </label>
            </div>
          </div>
          <p align="justify"> <font color="Maroon">embalsesPR</font> es un proyecto del grupo 
           <font color="blue">CienciaDatosPR</font> del <font color="blue">Departamento de 
           Matemáticas</font> de la <font color="Maroon"> Universidad de Puerto Rico en Humacao
           </font>.  
           Pueden enviar sus preguntas, comentarios, o sugerencias 
           a: <a href="mailto:elio.ramos@upr.edu">elio.ramos@upr.edu</a></p>
          <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">
            <img alt="Licencia Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png"></a><br>
            <span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">EmbalsesPR
            </span> por <a xmlns:cc="http://creativecommons.org/ns#" href="mate.uprh.edu" property="cc:attributionName" rel="cc:attributionURL">CienciaDatosPR/
            Matemáticas/UPR-Humacao</a> se distribuye bajo una <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Licencia Creative 
            Commons Atribución-NoComercial-CompartirIgual 4.0 Internacional</a>.
        </form>
      </div>
<script>
    let mymap; 
    let siteDict = {};

    ///////////////////////////////////
    // Funcion para inicializar el mapa
    ///////////////////////////////////

    function inicializaMapa()
    {
    let centro = [18.25178,-66.254513]; 
    mymap = L.map('mapid').setView(centro, 9);
    let atrib1 = 'Map data &copy; <a href="https://www.openstreetmap.org/copyright">';
    let atrib2 = 'OpenStreetMap</a> contributors, Imagery © <a href="https://www.mapbox.com/">Mapbox</a>';
    let atrib  = atrib1 + atrib2;
    let mytoken = 'pk.eyJ1IjoibWVjb2JpIiwiYSI6IjU4YzVlOGQ2YjEzYjE3NTcxOTExZTI2OWY3Y2Y1ZGYxIn0.LUg7xQhGH2uf3zA57szCyw';
    let myLayer = 'https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token={accessToken}';
    L.tileLayer(myLayer, {
        attribution: atrib,
        maxZoom: 24,
        id: 'mapbox/streets-v11',
        tileSize: 512,
        zoomOffset: -1,
        accessToken: mytoken}).addTo(mymap);

    /////////////
    // Leyenda //
    /////////////

    var leyenda = L.control({position: 'bottomleft'});
    leyenda.onAdd = function (mymap)
    {
    var div = L.DomUtil.create('div', 'info leyenda'),
        niveles = ['Seguridad', 'Ajuste', 'Control', 'Observacion'],
        colores = ['green', 'blue', 'yellow', 'darkorange'];

    div.innerHTML += "<h4>Nivel</h4>";
    for(let i=0; i < 4; i++)
    {
      div.innerHTML += '<i style="background:'+colores[i]+'"></i><span>'+niveles[i]+'</span><br>';
    }
    return div;
    };
    leyenda.addTo(mymap);
    }

    ////////////////////////////////////////////////////////////////////
    // Funcion la cual crea un diccionario con los datos de los embalses
    ////////////////////////////////////////////////////////////////////

    function createDictionary()
    {
    let url ="https://raw.githubusercontent.com/mecobi/archivos_ejemplo/main/embalses.csv";

    Plotly.d3.csv(url,function(data){
    for(let i=0;i < data.length;i++)
    {
      siteDict[data[i].siteID] = {nombre:data[i].nombre,
                                  lat:data[i].latitude,
                                  lon:data[i].longitude,
                                  desborde:data[i].desborde,
                                  seguridad:data[i].seguridad,
                                  observacion:data[i].observacion,
                                  ajuste:data[i].ajuste,
                                  control:data[i].control};
    }
    });
    }

    //////////////////////////////////////////////////////////////////////////
    // Funcion para filtrar la fecha y nivel de los embalses en el diccionario
    //////////////////////////////////////////////////////////////////////////

    function filtraDatos(data)
    {
    let fecha = [],
      nivel = [];

    const filtered = data.split('\n');
    let colNivel;

    for(let i=0;i < filtered.length;i++)
    {
    if (filtered[i].slice(0,9) == "agency_cd")
    {
      let header = filtered[i].split("\t");
      colNivel = header.findIndex(element => element.includes("_62616"))
    }

    if(filtered[i].slice(0,4) == "USGS")
    {
      let fila = filtered[i].split('\t');
      fecha.push(fila[2]);
      nivel.push(parseFloat(fila[colNivel]));
    }
    }
    return [fecha,nivel];
    }

    ////////////////////////////////////////////////////////
    // Funcion que devuelve la normalizacion de los embalses
    ////////////////////////////////////////////////////////

    function normalizacion(nivel, control, desborde)
    {
    let num = nivel - control,
      denominado = desborde - control,
      normalizacion = (num/denominado);
    return normalizacion;
    }

    //////////////////////////////////////////////////////////
    // Funcion que devuelve el nivel pendiente de los embalses
    //////////////////////////////////////////////////////////

    function tendencia(fecha, nivel)
    {
    let now = Date().slice(8,10),
      tendencia =[];

    for(let i=0;i < nivel.length;i++)
    {
    if (fecha[i].slice(8,10) == now)
    {
      tendencia.push(parseFloat(nivel[i]));
    }
    }
    let pendiente = tendencia[tendencia.length -1] - tendencia[0];
    return pendiente; 
    }

    ////////////////////////////////////////////////
    // Funcion que crea marcadores para cada embalse
    ////////////////////////////////////////////////

    function createMarker(miEmbalse)
    {
    Plotly.d3.text("https://waterdata.usgs.gov/pr/nwis/uv/?format=rdb&site_no=" + miEmbalse, function(data){
    let datos = filtraDatos(data),
        lat = siteDict[miEmbalse].lat,
        lon = siteDict[miEmbalse].lon,
        nombre = siteDict[miEmbalse].nombre,
        desborde = parseFloat(siteDict[miEmbalse].desborde),
        seguridad = parseFloat(siteDict[miEmbalse].seguridad),
        observacion = parseFloat(siteDict[miEmbalse].observacion),
        ajuste = parseFloat(siteDict[miEmbalse].ajuste),
        control = parseFloat(siteDict[miEmbalse].control),
        nivel = datos[1].pop(),
        nivel_pend = datos[1], 
        fecha = datos[0],
        pendiente = tendencia(fecha, nivel_pend),
        mensaje = "Sup..soy " + nombre + " <br> Mi nivel es " + parseFloat(nivel).toFixed(2) + " metros",
        rect1, rect2, rect3, rect4, rect5,
        icono, marcadorIcono, marcadorTend, color,
        
        //////////////////////////////////////////////////
        // norm1 y nivel_1 son variables para nivel
        // norm2 y nivel_2 son variables para desborde
        // norm3 y nivel_3 son variables para seguridad
        // norm4 y nivel_4 son variables para observacion
        // norm5 y nivel_5 son variables para ajuste
        // norm5 y nivel_6 son variables para ajuste
        //////////////////////////////////////////////////
        
        norm1 = normalizacion(nivel,control,desborde),
        norm2 = normalizacion(desborde,control,desborde),
        norm3 = normalizacion(seguridad,control,desborde),
        norm4 = normalizacion(observacion,control,desborde),
        norm5 = normalizacion(ajuste,control,desborde),
        norm6 = normalizacion(control,control,desborde),
        nivel_1 = (0.09 - (norm1/9).toFixed(2)),
        nivel_2 = (0.09 - (norm2/9).toFixed(2)),
        nivel_3 = (0.09 - (norm3/9).toFixed(2)),
        nivel_4 = (0.09 - (norm4/9).toFixed(2)),
        nivel_5 = (0.09 - (norm5/9).toFixed(2)),
        nivel_6 = (0.09 - (norm6/9).toFixed(2)),
        largo = 0.04;

    if (nivel_3 < 0){nivel_3=-nivel_3;}
    if (nivel_4 < 0){nivel_4=-nivel_4;}
    if (nivel_5 < 0){nivel_5=-nivel_5;}
    if (nivel_6 < 0){nivel_6=-nivel_6;}

    if (nivel >= seguridad){color = 'green';}
    else if (nivel >= observacion && nivel < seguridad){color = 'blue'}
    else if (nivel >= ajuste && nivel < observacion){color = 'yellow'}
    else if (nivel <= control){color = 'darkorange'}

    rect1 = L.rectangle([[lat-nivel_6.toFixed(2),lon-largo],[lat-nivel_1.toFixed(2),lon]],
                            {color: color,
                             colorOpacity:0.02,
                             fillColor:color,
                             fillOpacity:0.75,
                             weight: 0.5}).addTo(mymap);
    rect2 = L.rectangle([[lat-nivel_3.toFixed(2),lon],[lat-nivel_4.toFixed(2),lon-largo]],
                              {color: "blue",
                               colorOpacity:0.09,
                               fillColor:"black",
                               fillOpacity:0.02,
                               weight: 1.5}).addTo(mymap);
    rect3 = L.rectangle([[lat-nivel_4.toFixed(2),lon],[lat-nivel_5.toFixed(2),lon-largo]],
                              {color: "yellow",
                               colorOpacity:0.09,
                               fillColor:"black",
                               fillOpacity:0.02,
                               weight: 1.5}).addTo(mymap);
    rect4 = L.rectangle([[lat-nivel_5.toFixed(2),lon],[lat-nivel_1.toFixed(2),lon-largo]],
                               {color: "darkorange",
                                colorOpacity:0.09,
                                fillColor:"black",
                                fillOpacity:0.02,
                                weight: 1.5}).addTo(mymap);
    rect5 = L.rectangle([[lat-nivel_6.toFixed(2),lon],[lat-nivel_2.toFixed(2),lon-largo]],
                              {color: "black",
                               colorOpacity:0.09,
                               fillColor:"black",
                               fillOpacity:0.02,
                               weight: 2}).addTo(mymap);

    if(pendiente > 0)
    {icono= 'https://cdn0.iconfinder.com/data/icons/flat-round-arrow-arrow-head/512/Green_Arrow_Top-512.png?raw=true';}
    else if(pendiente == 0)
    {icono= 'https://cdn0.iconfinder.com/data/icons/ui-essence/32/_26ui-512.png?raw=true';}
    else if(pendiente < 0)
    {icono= 'https://cdn0.iconfinder.com/data/icons/flat-round-arrow-arrow-head/512/Red_Arrow_Down-512.png?raw=true';}

    marcadorIcono = L.icon({iconUrl: icono, iconSize: [25,25], iconAnchor: [15,30], className: 'icono'});
    marcadorTend = L.marker([lat-nivel_2.toFixed(2)+0.017,lon-0.015], {icon: marcadorIcono}).addTo(mymap);
    });
    }

    //////////////////////////////
    // Funcion que imprime el mapa
    //////////////////////////////

    function procesaEmbalse(){
    for(const [key,value] of Object.entries(siteDict))
    {
    createMarker(key);
    }
    }

    createDictionary();
    inicializaMapa();
    setTimeout(procesaEmbalse,500);
</script>
<style>
    .leyenda {
    padding: 6px 8px;
    font: 14px Arial, Helvetica, sans-serif;
    background: black;
    box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
    border-radius: 5px;
    line-height: 24px;
    color: #555;
    }
    .leyenda h4 {
    text-align: center;
    font-size: 18px;
    margin: 2px 12px 8px;
    color: white;
    opacity: 0.85;
    }
    .leyenda span {
    position: relative;
    bottom: 3px;
    color: white;
    opacity: 0.85;
    }
    .leyenda i {
    width: 18px;
    height: 18px;
    float: left;
    margin: 0 8px 0 0;
    opacity: 0.75;
    }
</style>
</body>
</html>